#include "Piece.h"
#include <windows.h>
#include <time.h>

Piece::Piece()
{
	myWidth = 20;
	myColor = RGB(255, 0, 255);
	myActive = true;
	myExists = true;
	myScrub = true;
}

Piece::Piece(int width, COLORREF color)
{
	myWidth = width;
	myColor = color;
	myActive = true;
	myExists = true;
	myScrub = true;
}

void Piece::display(HDC hdc, int left, int top, int xShift, int yShift)
{
	if (myScrub)
	{
		if (myExists)
		{

			RECT rect;
			rect.top = top * myWidth + yShift;
			rect.left = left * myWidth + xShift;
			rect.bottom = (top + 1) * myWidth + yShift;
			rect.right = (left + 1) * myWidth + xShift;

			SelectObject (hdc, CreateSolidBrush(myColor)); //the device context is now the value myColor - meaning myColor has been selected into the DC
			Rectangle(hdc, rect.left, rect.top, rect.right, rect.bottom); //myColor(now the hdc) is used to fill the logical coordinates of the square provided
			//FillRect(hdc, &rect, CreateSolidBrush(myColor));
			DrawEdge(hdc, &rect, EDGE_RAISED, BF_BOTTOMRIGHT); //the specified bottomright edge is raised to give the appearance as 'existent'
		}
		else
		{
			RECT rect;
			rect.top = top * myWidth + yShift;
			rect.left = left * myWidth + xShift;
			rect.bottom = (top + 1) * myWidth + yShift;
			rect.right = (left + 1) * myWidth + xShift;

			SelectObject (hdc, CreateSolidBrush(RGB(0, 0, 0)));
			Rectangle(hdc, rect.left, rect.top, rect.right, rect.bottom);
			//FillRect(hdc, &rect, CreateSolidBrush(RGB(0,0,0)));
			DrawEdge(hdc, &rect, EDGE_SUNKEN, BF_BOTTOMRIGHT);
		}
		myScrub = false;
	}
}

void Piece::setActive(bool setto)
{
	myActive = setto;
	if (setto)
		myExists = true;
}

void Piece::setExists(bool setto)
{
	myExists = setto;
	if (!setto)
		myActive = false;
}

void Piece::setScrub(bool setto)
{
	myScrub = setto;
}

void Piece::setColor(COLORREF setto)
{
	myColor = setto;
}


//accessors
bool Piece::getActive()
{
	return myActive;
}

bool Piece::getExists()
{
	return myExists;
}

bool Piece::getScrub()
{
	return myScrub;
}

COLORREF Piece::getColor()
{
	return myColor;
}

COLORREF Piece::colorspawn()
{
    COLORREF color;
    srand(time(NULL));
    int i = rand() % 7;
    int prev = i;
    int next;

        do{
            i = rand() % 5;  //try to get a proper random number
            next = i;
            //there is always an even distribution of numbers given by rand(),
            //such that any new number generated by rand() has probability 1/P of being
            //a number within range, also known as "uniform distribution"
            //instead of trying to circumvent the distribution, I have decided to work with it until a number falls in range

		}while((i < 0 || i > 7) && next == prev);


        if(i == 0)
            color = RGB(255, 0, 0);
        if(i == 1)
            color = RGB(0, 255, 0);
        if(i == 2)
            color = RGB(0, 0, 255);
        if(i == 3)
            color = RGB(193, 0, 210);
        if(i == 4)
            color = RGB(255, 255, 0);
    return color;
}
